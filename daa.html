<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Comprehensive Algorithm Reference</title>
<style>
  /* Reset and base */
  *, *::before, *::after {
    box-sizing: border-box;
  }
  body {
    margin: 0; padding: 1rem;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: #f5f8fa;
    color: #222;
    line-height: 1.6;
    max-width: 900px;
    margin-left: auto;
    margin-right: auto;
  }
  h1 {
    text-align: center;
    font-weight: 900;
    font-size: 2.8rem;
    margin-bottom: 0.25rem;
    letter-spacing: -0.05em;
    color: #1a73e8;
  }
  h2 {
    margin-top: 2.5rem;
    margin-bottom: 0.5rem;
    font-size: 1.75rem;
    color: #0f4c81;
    border-bottom: 3px solid #1a73e8;
    padding-bottom: 0.3rem;
  }
  h3 {
    margin-top: 1.25rem;
    margin-bottom: 0.3rem;
    color: #1a73e8;
    font-weight: 700;
  }
  p {
    margin: 0.25rem 0 1rem;
  }
  pre {
    background: #222f3e;
    color: #f8f8f2;
    padding: 1rem;
    border-radius: 6px;
    overflow-x: auto;
    font-family: 'Source Code Pro', monospace, monospace;
    font-size: 0.9rem;
    line-height: 1.4;
    margin: 0.5rem 0 1rem;
    white-space: pre-wrap;
  }
  code {
    font-family: 'Source Code Pro', monospace, monospace;
    font-size: 0.95rem;
  }
  .section-content {
    background: white;
    padding: 1rem 1.5rem;
    border-radius: 10px;
    box-shadow: 0 8px 16px rgb(26 115 232 / 0.1);
    margin-bottom: 2rem;
  }
  .definition {
    font-weight: 600;
    font-style: italic;
    color: #333;
  }
  .example {
    background: #eaf1fb;
    border-left: 5px solid #1a73e8;
    padding: 0.5rem 1rem;
    margin: 0.5rem 0 1rem;
    font-style: italic;
    color: #0f4c81;
  }
  .complexity {
    font-weight: 600;
    margin: 0.25rem 0 1rem;
    color: #444;
  }
  @media (max-width: 600px) {
    body {
      padding: 0.5rem 0.8rem;
      font-size: 14px;
    }
    h1 {
      font-size: 2rem;
    }
    h2 {
      font-size: 1.4rem;
    }
    pre {
      font-size: 0.8rem;
    }
  }
</style>
</head>
<body>
<h1>Comprehensive Algorithm Reference</h1>

<section class="section-content" id="selection-sort">
  <h2>üîπ 1. Selection Sort</h2>
  <p class="definition">Definition: Selection Sort is a simple comparison-based sorting algorithm. It divides the array into a sorted and unsorted part and repeatedly selects the smallest element from the unsorted part and moves it to the sorted part.</p>
  <h3>Explanation:</h3>
  <ul>
    <li>Start with the first element.</li>
    <li>Find the smallest element in the remaining array.</li>
    <li>Swap it with the first element.</li>
    <li>Repeat this for all positions.</li>
  </ul>
  <h3>Pseudocode:</h3>
  <pre>for i ‚Üê 0 to n-2 do
    min ‚Üê i
    for j ‚Üê i+1 to n-1 do
        if A[j] &lt; A[min] then
            min ‚Üê j
    swap A[i] with A[min]</pre>
  <div class="example">
    <strong>Example:</strong><br />
    Array: [29, 10, 14, 37, 13]<br />
    Step 1: Smallest is 10 ‚Üí swap with 29 ‚Üí [10, 29, 14, 37, 13]<br />
    Step 2: Smallest in [29,14,37,13] is 13 ‚Üí [10, 13, 14, 37, 29] ... and so on.
  </div>
  <p class="complexity"><strong>Time Complexity:</strong> O(n¬≤) in all cases (best, average, worst)<br />
  <strong>Space Complexity:</strong> O(1) (in-place sorting)<br />
  <strong>Stable:</strong> No (relative order of equal elements not preserved)</p>
</section>

<section class="section-content" id="bubble-sort">
  <h2>üîπ 2. Bubble Sort</h2>
  <p class="definition">Definition: Bubble Sort repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order.</p>
  <h3>Explanation:</h3>
  <ul>
    <li>In each pass, the largest unsorted element ‚Äúbubbles‚Äù to the end.</li>
    <li>Repeats until the list is sorted.</li>
  </ul>
  <h3>Pseudocode:</h3>
  <pre>for i ‚Üê 0 to n-1 do
    for j ‚Üê 0 to n-i-2 do
        if A[j] &gt; A[j+1] then
            swap A[j], A[j+1]</pre>
  <div class="example">
    <strong>Example:</strong><br />
    Array: [5, 3, 8, 4, 2]<br />
    Pass 1: [3, 5, 4, 2, 8]<br />
    Pass 2: [3, 4, 2, 5, 8]<br />
    Pass 3: [3, 2, 4, 5, 8]<br />
    Pass 4: [2, 3, 4, 5, 8]
  </div>
  <p class="complexity"><strong>Time Complexity:</strong><br />
  Best: O(n) (already sorted)<br />
  Average/Worst: O(n¬≤)<br />
  <strong>Space Complexity:</strong> O(1)<br />
  <strong>Stable:</strong> Yes</p>
</section>

<section class="section-content" id="merge-sort">
  <h2>üîπ 3. Merge Sort</h2>
  <p class="definition">Definition: Merge Sort is a divide-and-conquer algorithm. It divides the input array into two halves, recursively sorts them, and then merges the two sorted halves.</p>
  <h3>Steps:</h3>
  <ol>
    <li>Divide the unsorted list into sublists until each contains a single element.</li>
    <li>Merge sublists to produce new sorted sublists.</li>
    <li>Repeat until one sorted list remains.</li>
  </ol>
  <h3>Pseudocode:</h3>
  <pre>function MergeSort(A, low, high):
    if low &lt; high:
        mid ‚Üê (low + high)/2
        MergeSort(A, low, mid)
        MergeSort(A, mid+1, high)
        Merge(A, low, mid, high)</pre>
  <div class="example">
    <strong>Example:</strong><br />
    Array: [38, 27, 43, 3, 9]<br />
    Divide: [38, 27], [43, 3, 9] ‚Üí [38], [27], [43], [3], [9]<br />
    Merge: [27, 38], [3, 9, 43] ‚Üí [3, 9, 27, 38, 43]
  </div>
  <p class="complexity"><strong>Time Complexity:</strong> O(n log n) for all cases<br />
  <strong>Space Complexity:</strong> O(n) (temporary arrays)<br />
  <strong>Stable:</strong> Yes</p>
</section>

<section class="section-content" id="quick-sort">
  <h2>üîπ 4. Quick Sort</h2>
  <p class="definition">Definition: Quick Sort is a divide-and-conquer algorithm that picks a pivot element, partitions the array into two parts, and then recursively applies the same logic.</p>
  <h3>Explanation:</h3>
  <ul>
    <li>Choose a pivot (commonly the last element).</li>
    <li>Rearrange the array so that all elements less than pivot are on the left, and greater on the right.</li>
    <li>Recursively apply the same logic to the subarrays.</li>
  </ul>
  <h3>Pseudocode:</h3>
  <pre>function QuickSort(A, low, high):
    if low &lt; high:
        pivot ‚Üê Partition(A, low, high)
        QuickSort(A, low, pivot-1)
        QuickSort(A, pivot+1, high)</pre>
  <h3>Partition Function:</h3>
  <pre>function Partition(A, low, high):
    pivot ‚Üê A[high]
    i ‚Üê low - 1
    for j ‚Üê low to high - 1:
        if A[j] ‚â§ pivot:
            i ‚Üê i + 1
            swap A[i], A[j]
    swap A[i+1], A[high]
    return i + 1</pre>
  <div class="example">
    <strong>Example:</strong><br />
    Array: [10, 7, 8, 9, 1, 5], Pivot = 5<br />
    After Partition: [1, 5, 8, 9, 10, 7] and recurse on each side
  </div>
  <p class="complexity"><strong>Time Complexity:</strong><br />
  Best/Average: O(n log n)<br />
  Worst: O(n¬≤) (when array is already sorted and pivot is worst)<br />
  <strong>Space Complexity:</strong> O(log n) (recursive stack)<br />
  <strong>Stable:</strong> No</p>
</section>

<section class="section-content" id="sequential-search">
  <h2>üîπ 5. Sequential Search</h2>
  <p class="definition">Definition: Also known as linear search, it checks each element of the list until the desired element is found or the list ends.</p>
  <h3>Pseudocode:</h3>
  <pre>for i ‚Üê 0 to n-1 do
    if A[i] == key:
        return i
return -1</pre>
  <h3>Explanation:</h3>
  <ul>
    <li>Begin from the first element.</li>
    <li>Compare each element to the target value.</li>
    <li>Return index if found, else return -1.</li>
  </ul>
  <div class="example">
    <strong>Example:</strong><br />
    Array: [4, 2, 7, 1, 3], Key: 7 ‚Üí Found at index 2
  </div>
  <p class="complexity"><strong>Time Complexity:</strong><br />
  Best: O(1) (if first element)<br />
  Worst: O(n) (if not found or at last index)</p>
</section>

<section class="section-content" id="binary-search">
  <h2>üîπ 6. Binary Search</h2>
  <p class="definition">Definition: Binary Search is an efficient algorithm for finding an item in a <em>sorted</em> array by repeatedly dividing the search interval in half.</p>
  <h3>Pseudocode:</h3>
  <pre>low ‚Üê 0
high ‚Üê n - 1
while low ‚â§ high:
    mid ‚Üê (low + high) / 2
    if A[mid] == key:
        return mid
    else if key &lt; A[mid]:
        high ‚Üê mid - 1
    else:
        low ‚Üê mid + 1
return -1</pre>
  <h3>Explanation:</h3>
  <ul>
    <li>Find the middle element.</li>
    <li>If it matches the key, return the index.</li>
    <li>If key is smaller, search the left half.</li>
    <li>If key is larger, search the right half.</li>
  </ul>
  <div class="example">
    <strong>Example:</strong><br />
    Array: [1, 3, 5, 7, 9], Key: 5 ‚Üí Mid = 2 ‚Üí Found
  </div>
  <p class="complexity"><strong>Time Complexity:</strong> O(log n)<br />
  <strong>Space Complexity:</strong> O(1) for iterative, O(log n) for recursive<br />
  <strong>Limitation:</strong> Requires sorted input array</p>
</section>

<section class="section-content" id="brute-force-string-matching">
  <h2>üîπ 7. Brute Force String Matching</h2>
  <p class="definition">Definition: Brute Force String Matching is the simplest technique to find a pattern in a text. It checks every possible position in the text where the pattern may occur and compares character by character.</p>
  <h3>Explanation:</h3>
  <ul>
    <li>Compare pattern P with text T starting at position 0.</li>
    <li>Move the pattern one position forward each time and repeat the comparison.</li>
    <li>Stop when a match is found or all positions are checked.</li>
  </ul>
  <h3>Pseudocode:</h3>
  <pre>for i ‚Üê 0 to n - m do
    j ‚Üê 0
    while j &lt; m and T[i + j] == P[j] do
        j ‚Üê j + 1
    if j == m:
        return i
return -1</pre>
  <div class="example">
    <strong>Example:</strong><br />
    Text: "ABCABCD", Pattern: "ABC"<br />
    Match at index 0 ‚Üí "ABC" == "ABC"
  </div>
  <p class="complexity"><strong>Time Complexity:</strong><br />
  Worst-case: O(n * m)<br />
  Best-case: O(n) (if mismatches early)<br />
  <strong>Space Complexity:</strong> O(1)<br />
  <strong>Use Case:</strong> Simple to implement but inefficient for large texts or patterns.</p>
</section>

<section class="section-content" id="matrix-multiplication">
  <h2>üîπ 8. Matrix Multiplication</h2>
  <p class="definition">Definition: Matrix multiplication involves multiplying two matrices A and B to produce a result matrix C such that each element C[i][j] is the sum of A[i][k] * B[k][j].</p>
  <h3>Pseudocode:</h3>
  <pre>for i ‚Üê 0 to n-1:
    for j ‚Üê 0 to n-1:
        C[i][j] ‚Üê 0
        for k ‚Üê 0 to n-1:
            C[i][j] ‚Üê C[i][j] + A[i][k] * B[k][j]</pre>
  <h3>Explanation:</h3>
  <ul>
    <li>Outer loops iterate over row i and column j.</li>
    <li>Inner loop calculates the dot product of row i of A and column j of B.</li>
  </ul>
  <div class="example">
    <strong>Example:</strong><br />
    A = [[1, 2], [3, 4]], B = [[2, 0], [1, 2]]<br />
    C[0][0] = 1*2 + 2*1 = 4<br />
    C[0][1] = 1*0 + 2*2 = 4
  </div>
  <p class="complexity"><strong>Time Complexity:</strong> O(n¬≥) for naive method<br />
  <strong>Space Complexity:</strong> O(n¬≤) for result matrix</p>
</section>

<section class="section-content" id="decimal-to-binary">
  <h2>üîπ 9. Decimal to Binary Conversion</h2>
  <p class="definition">Definition: Convert a decimal number to binary by repeatedly dividing the number by 2 and noting the remainder.</p>
  <h3>Pseudocode:</h3>
  <pre>while n &gt; 0:
    print(n % 2)
    n ‚Üê n // 2</pre>
  <h3>Explanation:</h3>
  <ul>
    <li>Divide the number by 2.</li>
    <li>Remainders give binary digits from LSB to MSB.</li>
    <li>Read the remainders in reverse order for final binary number.</li>
  </ul>
  <div class="example">
    <strong>Example:</strong><br />
    Decimal = 13<br />
    Steps: 13%2 = 1, 6%2 = 0, 3%2 = 1, 1%2 = 1 ‚Üí Binary = 1101
  </div>
  <p class="complexity"><strong>Time Complexity:</strong> O(log n)<br />
  <strong>Space Complexity:</strong> O(log n) (due to bit storage)</p>
</section>

<section class="section-content" id="find-max-element">
  <h2>üîπ 10. Find Maximum Element in Array</h2>
  <p class="definition">Definition: This algorithm scans through the array and returns the largest value.</p>
  <h3>Pseudocode:</h3>
  <pre>max ‚Üê A[0]
for i ‚Üê 1 to n-1:
    if A[i] &gt; max:
        max ‚Üê A[i]
return max</pre>
  <div class="example">
    <strong>Example:</strong><br />
    Array: [5, 17, 3, 9] ‚Üí Max = 17
  </div>
  <p class="complexity"><strong>Time Complexity:</strong> O(n)<br />
  <strong>Space Complexity:</strong> O(1)</p>
</section>

<section class="section-content" id="find-unique-elements">
  <h2>üîπ 11. Find Unique Elements in Array</h2>
  <p class="definition">Definition: Check whether all elements in the array are unique.</p>
  <h3>Pseudocode:</h3>
  <pre>for i ‚Üê 0 to n-1:
    for j ‚Üê i+1 to n-1:
        if A[i] == A[j]:
            return False
return True</pre>
  <div class="example">
    <strong>Example:</strong><br />
    Array: [3, 1, 4, 2] ‚Üí All unique ‚Üí returns True<br />
    Array: [3, 1, 4, 1] ‚Üí Duplicate ‚Üí returns False
  </div>
  <p class="complexity"><strong>Time Complexity:</strong> O(n¬≤) (brute-force)<br />
  Optimized: O(n log n) with sorting or O(n) with hash set<br />
  <strong>Space Complexity:</strong> O(1) (brute-force)</p>
</section>

<section class="section-content" id="horspool-string-matching">
  <h2>üîπ 12. Horspool‚Äôs String Matching Algorithm</h2>
  <p class="definition">Definition: Horspool‚Äôs algorithm improves over brute force by using a shift table to skip unnecessary comparisons.</p>
  <h3>Steps:</h3>
  <ol>
    <li>Preprocess pattern P to build a shift table.</li>
    <li>Compare pattern from right to left.</li>
    <li>On mismatch, use shift table to jump ahead.</li>
  </ol>
  <h3>Pseudocode Overview:</h3>
  <pre>BuildShiftTable(P)
Set i = m-1 (end of pattern)
while i &lt; n:
    compare P from end with T[i]
    if match ‚Üí report position
    else shift using table</pre>
  <div class="example">
    <strong>Example:</strong><br />
    Text: "abcdabcxabcdabcdabcy"<br />
    Pattern: "abcdabcy"<br />
    Mismatch occurs early, so pattern jumps forward efficiently.
  </div>
  <p class="complexity"><strong>Time Complexity:</strong><br />
  Best/Average: O(n)<br />
  Worst-case: O(nm)<br />
  <strong>Space Complexity:</strong> O(k) where k = alphabet size<br />
  <strong>Advantage:</strong> Faster than brute force for large texts</p>
</section>

<section class="section-content" id="prims-algorithm">
  <h2>üîπ 13. Prim‚Äôs Algorithm (Minimum Spanning Tree)</h2>
  <p class="definition">Definition: Prim‚Äôs algorithm finds a Minimum Spanning Tree (MST) for a weighted undirected graph. It starts with a single vertex and grows the MST by adding the minimum weight edge from the tree to a vertex not yet in the tree.</p>
  <h3>Steps:</h3>
  <ol>
    <li>Initialize all vertices as not in MST.</li>
    <li>Choose a starting vertex and mark it as part of MST.</li>
    <li>At each step, pick the smallest edge that connects a vertex in MST to a vertex not in MST.</li>
    <li>Repeat until all vertices are included.</li>
  </ol>
  <h3>Pseudocode:</h3>
  <pre>Initialize key[] ‚Üê ‚àû, parent[] ‚Üê -1, MST[] ‚Üê false
key[0] ‚Üê 0
for count ‚Üê 0 to V-1:
    u ‚Üê vertex with minimum key[] not in MST
    MST[u] ‚Üê true
    for each neighbor v of u:
        if weight[u][v] &lt; key[v] and v not in MST:
            parent[v] ‚Üê u
            key[v] ‚Üê weight[u][v]</pre>
  <div class="example">
    <strong>Example:</strong><br />
    Graph: A-B (2), A-C (3), B-C (1), B-D (4), C-D (5)<br />
    Start at A ‚Üí MST edges: A-B, B-C, B-D with total weight = 7
  </div>
  <p class="complexity"><strong>Time Complexity:</strong> O(V¬≤) with adjacency matrix, O(E log V) with priority queue + adjacency list<br />
  <strong>Space Complexity:</strong> O(V)</p>
</section>

<section class="section-content" id="kruskals-algorithm">
  <h2>üîπ 14. Kruskal‚Äôs Algorithm (Minimum Spanning Tree)</h2>
  <p class="definition">Definition: Kruskal‚Äôs algorithm builds the MST by sorting all the edges by weight and adding them one by one to the MST if they don‚Äôt form a cycle.</p>
  <h3>Steps:</h3>
  <ol>
    <li>Sort all edges in non-decreasing order of weights.</li>
    <li>Initialize MST as empty.</li>
    <li>For each edge (u, v):</li>
    <ul>
      <li>If u and v are in different sets, add the edge to MST and union their sets.</li>
    </ul>
  </ol>
  <h3>Pseudocode:</h3>
  <pre>Sort all edges by weight
Initialize parent[] for union-find
for each edge (u, v):
    if find(u) ‚â† find(v):
        add (u, v) to MST
        union(u, v)</pre>
  <div class="example">
    <strong>Example:</strong><br />
    Same graph as above. Edges in order: B-C (1), A-B (2), A-C (3), B-D (4), C-D (5)<br />
    Pick B-C, A-B, B-D ‚Üí MST weight = 7
  </div>
  <p class="complexity"><strong>Time Complexity:</strong> O(E log E) due to sorting edges<br />
  <strong>Space Complexity:</strong> O(V) with union-find structure</p>
</section>

<section class="section-content" id="dijkstras-algorithm">
  <h2>üîπ 15. Dijkstra‚Äôs Algorithm (Single Source Shortest Path)</h2>
  <p class="definition">Definition: Dijkstra‚Äôs algorithm finds the shortest path from a source node to all other nodes in a weighted graph with non-negative weights.</p>
  <h3>Steps:</h3>
  <ol>
    <li>Set distance to all vertices as ‚àû and source as 0.</li>
    <li>Use a priority queue to pick the minimum distance vertex not yet processed.</li>
    <li>Update distances of its adjacent vertices if a shorter path is found.</li>
  </ol>
  <h3>Pseudocode:</h3>
  <pre>Initialize dist[] ‚Üê ‚àû, dist[source] ‚Üê 0
Create a min-priority queue of all vertices
while queue is not empty:
    u ‚Üê extract-min
    for each neighbor v of u:
        if dist[u] + weight(u, v) &lt; dist[v]:
            dist[v] ‚Üê dist[u] + weight(u, v)</pre>
  <div class="example">
    <strong>Example:</strong><br />
    Graph with edges: A-B(4), A-C(1), C-B(2), B-D(1), C-D(5)<br />
    From A ‚Üí A-C = 1, C-B = 3, B-D = 4
  </div>
  <p class="complexity"><strong>Time Complexity:</strong><br />
  O(V¬≤) with array<br />
  O((V + E) log V) with priority queue<br />
  <strong>Space Complexity:</strong> O(V)</p>
</section>

<section class="section-content" id="huffman-coding">
  <h2>üîπ 16. Huffman Coding</h2>
  <p class="definition">Definition: Huffman Coding is a greedy algorithm used for lossless data compression. It assigns shorter binary codes to more frequent characters and longer codes to less frequent ones.</p>
  <h3>Steps:</h3>
  <ol>
    <li>Create a min-heap with all characters and their frequencies.</li>
    <li>While the heap has more than one node:</li>
    <ul>
      <li>Extract the two nodes with the smallest frequency.</li>
      <li>Create a new internal node with their sum as frequency.</li>
      <li>Insert the new node back into the heap.</li>
    </ul>
    <li>The remaining node is the root of the Huffman Tree.</li>
  </ol>
  <h3>Pseudocode:</h3>
  <pre>Build a priority queue (min-heap) with all characters
while heap.size &gt; 1:
    left ‚Üê extractMin()
    right ‚Üê extractMin()
    newNode ‚Üê internal node with freq = left.freq + right.freq
    newNode.left = left, newNode.right = right
    insert newNode into heap
Return root of Huffman Tree</pre>
  <div class="example">
    <strong>Example:</strong><br />
    Characters: A:5, B:9, C:12, D:13, E:16, F:45<br />
    Huffman Tree gives codes like: F=0, C=100, D=101, etc.
  </div>
  <p class="complexity"><strong>Time Complexity:</strong> O(n log n) where n = number of characters<br />
  <strong>Space Complexity:</strong> O(n)</p>
</section>

<section class="section-content" id="floyd-warshall">
  <h2>üîπ 17. Floyd-Warshall Algorithm (All-Pairs Shortest Path)</h2>
  <p class="definition">Definition: The Floyd-Warshall algorithm finds shortest paths between all pairs of vertices in a weighted graph (can handle negative weights, but not negative cycles).</p>
  <h3>Steps:</h3>
  <ol>
    <li>Initialize distance matrix dist with edge weights.</li>
    <li>For each vertex k, update dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])</li>
  </ol>
  <h3>Pseudocode:</h3>
  <pre>for k ‚Üê 1 to n:
    for i ‚Üê 1 to n:
        for j ‚Üê 1 to n:
            if dist[i][k] + dist[k][j] &lt; dist[i][j]:
                dist[i][j] ‚Üê dist[i][k] + dist[k][j]</pre>
  <div class="example">
    <strong>Example:</strong><br />
    Initial matrix:<br />
    0   5   ‚àû   10<br />
    ‚àû   0   3   ‚àû<br />
    ‚àû   ‚àû   0   1<br />
    ‚àû   ‚àû   ‚àû   0<br />
    After running the algorithm, we get shortest distances between all pairs.
  </div>
  <p class="complexity"><strong>Time Complexity:</strong> O(n¬≥)<br />
  <strong>Space Complexity:</strong> O(n¬≤)</p>
</section>

<section class="section-content" id="warshalls-algorithm">
  <h2>üîπ 18. Warshall‚Äôs Algorithm (Transitive Closure of a Graph)</h2>
  <p class="definition">Definition: Warshall‚Äôs algorithm computes the transitive closure of a directed graph ‚Äî determining which vertices are reachable from each vertex.</p>
  <h3>Steps:</h3>
  <ol>
    <li>Use the adjacency matrix of the graph.</li>
    <li>For each intermediate vertex k, update path[i][j] = path[i][j] OR (path[i][k] AND path[k][j])</li>
  </ol>
  <h3>Pseudocode:</h3>
  <pre>for k ‚Üê 0 to n-1:
    for i ‚Üê 0 to n-1:
        for j ‚Üê 0 to n-1:
            path[i][j] ‚Üê path[i][j] or (path[i][k] and path[k][j])</pre>
  <div class="example">
    <strong>Example:</strong><br />
    Adjacency matrix:<br />
    0 1 0<br />
    0 0 1<br />
    1 0 0<br />
    After applying Warshall's algorithm, the matrix tells you reachability between all vertex pairs.
  </div>
  <p class="complexity"><strong>Time Complexity:</strong> O(n¬≥)<br />
  <strong>Space Complexity:</strong> O(n¬≤)</p>
</section>

<section class="section-content" id="knapsack-problem">
  <h2>üîπ 19. 0/1 Knapsack Problem (Dynamic Programming)</h2>
  <p class="definition">Definition: Given n items, each with weight w[i] and value v[i], and a knapsack of capacity W, determine the maximum total value of items that can be put in the knapsack such that each item is either included or excluded (0/1).</p>
  <h3>Steps:</h3>
  <ol>
    <li>Define dp[i][w] as the max value using first i items with total weight w.</li>
    <li>For each item i:</li>
    <ul>
      <li>If w[i] &gt; w: not included ‚Üí dp[i][w] = dp[i-1][w]</li>
      <li>Else: included or not ‚Üí dp[i][w] = max(dp[i-1][w], v[i] + dp[i-1][w - w[i]])</li>
    </ul>
  </ol>
  <h3>Pseudocode:</h3>
  <pre>for i ‚Üê 0 to n:
    for w ‚Üê 0 to W:
        if i == 0 or w == 0:
            dp[i][w] ‚Üê 0
        else if wt[i-1] ‚â§ w:
            dp[i][w] ‚Üê max(val[i-1] + dp[i-1][w-wt[i-1]], dp[i-1][w])
        else:
            dp[i][w] ‚Üê dp[i-1][w]</pre>
  <div class="example">
    <strong>Example:</strong><br />
    Items: val = [60, 100, 120], wt = [10, 20, 30], Capacity = 50<br />
    Max value: 220 (items 2 and 3)
  </div>
  <p class="complexity"><strong>Time Complexity:</strong> O(nW)<br />
  <strong>Space Complexity:</strong> O(nW) (can be reduced to O(W) using 1D array)</p>
</section>

<section class="section-content" id="n-queens">
  <h2>üîπ 20. N-Queens Problem (Backtracking)</h2>
  <p class="definition">Definition: Place N queens on an N√óN chessboard such that no two queens threaten each other (no two queens share the same row, column, or diagonal).</p>
  <h3>Steps:</h3>
  <ol>
    <li>Place a queen row by row.</li>
    <li>At each step, check if current position is safe.</li>
    <li>If safe, place the queen and recurse.</li>
    <li>If a solution is found, print it.</li>
  </ol>
  <h3>Pseudocode:</h3>
  <pre>function solveNQueens(row):
    if row == N:
        print board
        return
    for col ‚Üê 0 to N-1:
        if isSafe(row, col):
            placeQueen(row, col)
            solveNQueens(row + 1)
            removeQueen(row, col)</pre>
  <p class="complexity"><strong>Time Complexity:</strong> O(N!)<br />
  <strong>Space Complexity:</strong> O(N¬≤) for board or O(N) with arrays</p>
</section>

<section class="section-content" id="subset-sum">
  <h2>üîπ 21. Subset Sum Problem (Backtracking)</h2>
  <p class="definition">Definition: Given a set of integers and a value sum, determine if a subset exists whose sum equals the given value.</p>
  <h3>Steps:</h3>
  <ol>
    <li>At each step, include or exclude the current item.</li>
    <li>If sum becomes 0 ‚Üí return true.</li>
    <li>If end of array is reached ‚Üí return false.</li>
  </ol>
  <h3>Pseudocode:</h3>
  <pre>function isSubsetSum(i, sum):
    if sum == 0: return true
    if i == n: return false
    if A[i] &gt; sum:
        return isSubsetSum(i+1, sum)
    return isSubsetSum(i+1, sum) or isSubsetSum(i+1, sum - A[i])</pre>
  <p class="complexity"><strong>Time Complexity:</strong> O(2^n)<br />
  <strong>Space Complexity:</strong> O(n)</p>
</section>

</body>
</html>

